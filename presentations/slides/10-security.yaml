sections:
  - name: "Security Model"
    slides:
      - id: sec_1
        title: "4-Layer Security Model"
        narration: |
          Layer 1: API Gateway
          Layer 2: Authentication
          Layer 3: Intent Validation
          Layer 4: Service Authorization
          Defense in depth
        duration: 25
        content_type: "diagram"
        content: |
          4-LAYER SECURITY DEFENSE
          ════════════════════════
          
          User Request
              ↓
          ╔════════════════════════════════╗
          ║  LAYER 1: API Gateway          ║
          ║  • Rate limiting               ║
          ║  • DDoS protection             ║
          ║  • TLS encryption              ║
          ║  • Request filtering           ║
          ╚════════════╤═══════════════════╝
                       ↓
          ╔════════════════════════════════╗
          ║  LAYER 2: Authentication       ║
          ║  • Verify user identity        ║
          ║  • JWT validation              ║
          ║  • Session management          ║
          ║  • Multi-factor auth           ║
          ╚════════════╤═══════════════════╝
                       ↓
          ╔════════════════════════════════╗
          ║  LAYER 3: Intent Validation    ║
          ║  • Verify LLM output           ║
          ║  • Check MCP constraints       ║
          ║  • Permission checks           ║
          ║  • Input sanitization          ║
          ╚════════════╤═══════════════════╝
                       ↓
          ╔════════════════════════════════╗
          ║  LAYER 4: Service Auth         ║
          ║  • Resource-level ACL          ║
          ║  • Data filtering              ║
          ║  • Audit logging               ║
          ║  • Response validation         ║
          ╚════════════╤═══════════════════╝
                       ↓
          ✓ Request delivered (secured)
      
      - id: sec_2
        title: "Layer 1: API Gateway"
        narration: |
          Rate limiting
          DDoS protection
          TLS encryption
          Request filtering
          First defense
        duration: 25
        content_type: "text"
        content: |
          API GATEWAY SECURITY
          ═══════════════════
          
          Rate Limiting:
          ├─ Max 100 requests/minute per IP
          ├─ Max 1000 requests/day per user
          ├─ Burst protection (sliding window)
          ├─ Honeypot detection
          └─ Gradual degradation under load
          
          DDoS Protection:
          ├─ Cloudflare / AWS Shield
          ├─ GeoIP filtering
          ├─ Suspicious pattern detection
          ├─ Automatic mitigation
          └─ Real-time alerting
          
          Encryption:
          ├─ TLS 1.3 minimum
          ├─ Certificate pinning
          ├─ HSTS headers
          ├─ Perfect forward secrecy
          └─ OCSP stapling
          
          Request Filtering:
          ├─ Content-Type validation
          ├─ Size limits (max 1MB)
          ├─ Header validation
          ├─ URL encoding checks
          └─ SQL injection prevention
      
      - id: sec_3
        title: "Layer 2: Authentication"
        narration: |
          User identity verification
          JWT tokens
          Session management
          Multi-factor options
          Know who user is
        duration: 25
        content_type: "code"
        content: |
          AUTHENTICATION LAYER
          ════════════════════
          
          JWT Token Structure:
          {
            "header": {
              "alg": "HS256",
              "typ": "JWT"
            },
            "payload": {
              "user_id": "123",
              "username": "john@example.com",
              "roles": ["user", "premium"],
              "iat": 1697000000,
              "exp": 1697003600,
              "aud": "api.example.com"
            },
            "signature": "..."
          }
          
          Multi-factor Authentication:
          ├─ Step 1: Username/password
          ├─ Step 2: TOTP app
          ├─ Step 3: Device fingerprint
          ├─ OR: Passwordless (WebAuthn)
          └─ Result: High-entropy identity
          
          Session Management:
          ├─ Token expires: 1 hour
          ├─ Refresh token: 30 days
          ├─ Device tracking
          ├─ Suspicious login alerts
          └─ Automatic logout on risk
      
      - id: sec_4
        title: "Layer 3: Intent Validation"
        narration: |
          Validate classified intent
          Check against user permissions
          Prevent intent injection
          Ensure LLM output safe
          NOVEL: Triple-layer authorization
          (user + agent + intent)
        duration: 25
        content_type: "diagram"
        content: |
          TRIPLE-LAYER AUTHORIZATION
          ═══════════════════════════
          
          Layer A: User Authentication (who?)
          └─ JWT, multi-factor, device fingerprint
          
          Layer B: Agent Authorization (what can LLM do?)
          └─ MCP constraints limit available tools
          └─ Tool parameters constrained by type/range
          
          Layer C: Intent Authorization (what does user want?)
          └─ User must have permission for resulting action
          └─ Even if LLM can call tool, must validate intent match
          
          ──────────────────────────────────
          
          Example: User wants to "search products"
          
          LAYER A: Is this really alice@example.com?
          ├─ JWT valid? ✓
          ├─ MFA passed? ✓
          ├─ Device recognized? ✓
          └─ Result: User authenticated
              ↓
          LAYER B: Can LLM call search_products?
          ├─ MCP lists search_products tool? ✓
          ├─ Parameters constrained? ✓
          ├─ No hallucinated functions? ✓
          └─ Result: Tool access allowed
              ↓
          LAYER C: Should alice do this?
          ├─ Alice has search permission? ✓
          ├─ Intent matches tool? ✓
          ├─ Parameters valid? ✓
          ├─ No privilege escalation? ✓
          └─ Result: Action authorized
              ↓
          ✓ Execute search
          
          Breakthrough: Traditional 2-layer (user + service)
          expands to 3-layer (user + agent + intent)
          because LLMs inject new authorization step
      
      - id: sec_5
        title: "Layer 4: Service Authorization"
        narration: |
          Service-level permissions
          Resource-level access control
          Data filtering
          Audit logging
          Final check
        duration: 25
        content_type: "text"
        content: |
          SERVICE AUTHORIZATION
          ═════════════════════
          
          Resource-Level ACL:
          ├─ User can read own orders? ✓
          ├─ User can delete own wishlist? ✓
          ├─ User can modify admin settings? ✗ (unauthorized)
          ├─ User can view other user's cart? ✗ (forbidden)
          └─ User can access product inventory? (depends on role)
          
          Data Filtering:
          ├─ ProductService: Show only published
          ├─ OrderService: Show only own orders
          ├─ UserService: Hide sensitive fields
          ├─ PaymentService: Mask card numbers
          └─ Each response filtered by policy
          
          Audit Logging:
          ├─ Log: timestamp, user_id, action, result
          ├─ Store: Immutable audit trail
          ├─ Retention: 7 years (compliance)
          ├─ Access: Only security team
          └─ Alert: Suspicious patterns
          
          Compliance:
          ├─ GDPR: User data deletion
          ├─ CCPA: Access request handling
          ├─ PCI-DSS: Payment data
          ├─ HIPAA: Health data
          └─ SOC2: Audit requirements
      
      - id: sec_6
        title: "MCP: Enterprise Context Integration"
        narration: |
          MCP enables LLM to integrate with enterprise systems
          Access domain knowledge and business logic
          Answers are contextualized to your business
          Enforced through MCP constraints
          This is what makes LLM powerful in enterprise
        duration: 25
        content_type: "code"
        content: |
          GENERIC LLM vs ENTERPRISE INTEGRATION
          ═════════════════════════════════════
          
          GENERIC LLM (Pre-Trained Knowledge)
          ├─ User asks: "Show gaming laptops"
          ├─ LLM generates generic recommendations
          ├─ Based on training data (2024)
          ├─ No context about YOUR business
          ├─ No access to YOUR inventory
          ├─ No knowledge of YOUR policies
          └─ Not enterprise-grade useful
          
          ENTERPRISE LLM (MCP-Integrated)
          ├─ User asks: "Show gaming laptops"
          ├─ LLM sees MCP: enterprise integration
          │  └─ Can access: ProductService
          │  └─ Must respect: company policies
          │  └─ Must follow: budget constraints
          ├─ LLM executes within MCP guardrails
          ├─ Gets: YOUR inventory, YOUR prices
          ├─ Applies: YOUR business logic
          └─ Returns: contextualized answer
          
          ──────────────────────────────────
          
          MCP Definition (enables safe integration):
          tools:
            - name: search_products
              parameters:
                - name: category
                  type: enum
                  values: [gaming, office, budget]
                - name: price_max
                  type: number
                  min: 0
                  max: 10000
          
          Benefit: LLM cannot make up functions
          ├─ Only tools in MCP available
          ├─ Only valid parameters accepted
          ├─ Only constrained value ranges allowed
          ├─ Invalid attempts fail gracefully
          └─ Forced to use real tools properly
          
          Result: LLM becomes AI agent
          ├─ Combines understanding with action
          ├─ Provides live, contextual results
          └─ Meets natural user expectation
